"use strict";(self.webpackChunk_spa_tools_website=self.webpackChunk_spa_tools_website||[]).push([[6560],{2475:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var i=n(7458),s=n(7996),o=n(5207);const r={title:"useInfiniteScroll",pagination_label:"Interaction Hooks: useInfiniteScroll",pagination_next:"interaction-hooks/use-is-hovered",pagination_prev:"interaction-hooks/use-detect-keydown",sidebar_label:"useInfiniteScroll",slug:"/interaction-hooks/use-infinite-scroll"},l="useInfiniteScroll()",c={id:"interaction-hooks/use-infinite-scroll",title:"useInfiniteScroll",description:"Stop time-warping your users back to the 1990's with antiquated pagination controls. Instead, streamline your data pagination experience by implementing infinite scrolling with the useInfiniteScroll hook.",source:"@site/docs/interaction-hooks/use-infinite-scroll.mdx",sourceDirName:"interaction-hooks",slug:"/interaction-hooks/use-infinite-scroll",permalink:"/spa-tools/interaction-hooks/use-infinite-scroll",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"useInfiniteScroll",pagination_label:"Interaction Hooks: useInfiniteScroll",pagination_next:"interaction-hooks/use-is-hovered",pagination_prev:"interaction-hooks/use-detect-keydown",sidebar_label:"useInfiniteScroll",slug:"/interaction-hooks/use-infinite-scroll"},sidebar:"docs",previous:{title:"Interaction Hooks: useDetectKeyDown",permalink:"/spa-tools/interaction-hooks/use-detect-keydown"},next:{title:"Interaction Hooks: useIsHovered",permalink:"/spa-tools/interaction-hooks/use-is-hovered"}},a={},d=[{value:"Usage",id:"usage",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Returns",id:"returns",level:3}];function h(e){const t={code:"code",h1:"h1",h3:"h3",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(o.D_,{packageName:"@spa-tools/interaction-hooks"}),"\n",(0,i.jsx)(t.h1,{id:"useinfinitescroll",children:"useInfiniteScroll()"}),"\n",(0,i.jsxs)(t.p,{children:["Stop time-warping your users back to the 1990's with antiquated pagination controls. Instead, streamline your data pagination experience by implementing infinite scrolling with the ",(0,i.jsx)(t.code,{children:"useInfiniteScroll"})," hook."]}),"\n",(0,i.jsx)(t.h3,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:"import { useCallback, useEffect, useRef, useState } from 'react';\nimport { useCallEndpoint } from '@spa-tools/api-client';\nimport { useInfiniteScroll } from '@spa-tools/interaction-hooks';\n\n// here we create a custom hook to fetch recipes from a server\n// using the useCallEndpoint hook from the @spa-tools/api-client package\nfunction useGetRecipes() {\n  return useCallEndpoint(\n    'https://dummyjson.com/recipes',\n    {\n      requestOptions: { recordLimit: 10 },\n      serverModelOptions: { jsonDataDotPath: 'recipes' },\n    },\n    // we pass true to enable appending of new records\n    true\n  );\n}\n\nfunction UseInfiniteScrollExample() {\n  // this will hold the ref to our scroll target, which is just a div that we\n  // place below our list of recipes to act as a sentinel for scroll intersection\n  const scrollTargetRef = useRef<HTMLDivElement>(null);\n  const [total, setTotal] = useState(0);\n  const [count, setCount] = useState(0);\n  const [getRecipes, recipesResult, isRecipesCallPending] = useGetRecipes();\n\n  // anytime our scroll target is intersected for vertical scroll, the hook\n  // will return true, which is how we know to fetch the next page of recipes\n  const isScrolling = useInfiniteScroll(scrollTargetRef);\n\n  const handleGetRecipes = useCallback(() => {\n    const recordCount = recipesResult?.data?.length ?? -1;\n    const totalCount = recipesResult?.total ?? 0;\n\n    setCount(recordCount);\n    setTotal(totalCount);\n\n    if (!isRecipesCallPending && recordCount < totalCount) {\n      getRecipes();\n    }\n  }, [getRecipes, isRecipesCallPending, recipesResult?.data?.length, recipesResult?.total]);\n\n  useEffect(() => {\n    if (isScrolling) {\n      // if the infinite scroll says we're scrolling,\n      // then we retrieve the next page of recipes\n      handleGetRecipes();\n    }\n  }, [handleGetRecipes, isScrolling]);\n\n  return (\n    <div>\n      <h4>\n        {count && total ? `${count === total ? `All ${count}` : `${count} of ${total}`} recipes retrieved!` : ''}\n        {count && total && count < total ? ' (scroll recipe list to load more)' : ''}\n      </h4>\n      <div style={{ height: '300px', overflowY: 'auto', padding: '1rem', width: '100%' }}>\n        <ul>{recipesResult?.data?.map((recipe) => <li key={recipe.id}>{recipe.name}</li>)}</ul>\n        {isRecipesCallPending && <div>Loading recipes...</div>}\n        <div ref={scrollTargetRef} />\n      </div>\n    </div>\n  );\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Name"}),(0,i.jsx)(t.th,{children:"Type"}),(0,i.jsx)(t.th,{children:"Required?"}),(0,i.jsx)(t.th,{children:"Default"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"bottomTriggerElement"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"React.RefObject"})}),(0,i.jsx)(t.td,{children:"yes"}),(0,i.jsx)(t.td,{children:"-"}),(0,i.jsx)(t.td,{children:"Holds a ref to an element that acts as sentinel for scroll intersection"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"disabled"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"boolean"})}),(0,i.jsx)(t.td,{children:"no"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"false"})}),(0,i.jsxs)(t.td,{children:["If set to ",(0,i.jsx)(t.code,{children:"true"}),", the hook will stop detecting scroll"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"bottomThresholdPercentage"})}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"number"})}),(0,i.jsx)(t.td,{children:"no"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"40"})}),(0,i.jsxs)(t.td,{children:[(0,i.jsx)("p",{children:"The distance (in percentage terms) from the bottom of the scroll target to its top which will act as intersection area that triggers the hook."})," This only starts to have impact if the trigger element contains content that results in substantial height"]})]})]})]}),"\n",(0,i.jsx)(t.h3,{id:"returns",children:"Returns"}),"\n",(0,i.jsxs)(t.p,{children:["Returns ",(0,i.jsx)(t.code,{children:"boolean"})," that will be ",(0,i.jsx)(t.code,{children:"true"})," when the respective target element is scrolling."]})]})}function u(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);