"use strict";(self.webpackChunk_spa_tools_website=self.webpackChunk_spa_tools_website||[]).push([[8069],{4303:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>u,toc:()=>h});var r=o(7458),n=o(7996),i=o(5207);const a={title:"Pre-Nav Confirmation",pagination_label:"Core Router Guide: Pre-Nav Confirmation",pagination_next:"core-router/guide-state-interpolation",pagination_prev:"core-router/guide-auth-check",sidebar_label:"Pre-Nav Confirmation",slug:"/core-router/guides/confirmation"},s="Pre-Nav Confirmation",u={id:"core-router/guide-confirmation",title:"Pre-Nav Confirmation",description:"As already mentioned, the @spa-tools/core-router package provides a way to execute pre-processing logic before navigating to a route. Another common scenario that falls into this category is prompting the user to confirm before proceeding with a navigation.",source:"@site/docs/core-router/guide-confirmation.mdx",sourceDirName:"core-router",slug:"/core-router/guides/confirmation",permalink:"/spa-tools/core-router/guides/confirmation",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Pre-Nav Confirmation",pagination_label:"Core Router Guide: Pre-Nav Confirmation",pagination_next:"core-router/guide-state-interpolation",pagination_prev:"core-router/guide-auth-check",sidebar_label:"Pre-Nav Confirmation",slug:"/core-router/guides/confirmation"},sidebar:"docs",previous:{title:"Core Router Guide: Pre-Route Auth Check",permalink:"/spa-tools/core-router/guides/auth-check"},next:{title:"Core Router Guide: State Interpolation",permalink:"/spa-tools/core-router/guides/state-interpolation"}},c={},h=[];function l(e){const t={code:"code",h1:"h1",p:"p",pre:"pre",...(0,n.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.D_,{packageName:"@spa-tools/core-router"}),"\n",(0,r.jsx)(t.h1,{id:"pre-nav-confirmation",children:"Pre-Nav Confirmation"}),"\n",(0,r.jsxs)(t.p,{children:["As already mentioned, the ",(0,r.jsx)(t.code,{children:"@spa-tools/core-router"})," package provides a way to execute pre-processing logic before navigating to a route. Another common scenario that falls into this category is prompting the user to confirm before proceeding with a navigation."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"import { CoreRouter, routesFactory } from '@spa-tools/core-router';\n\nconst createMyRoutes = routesFactory();\n\n// here we create two routes, one that is a signup form that requires\n// a dirty check before navigating away form and the other is just a\n// home page that does not\n//\n// the dirtyCheck is a 100% custom property that we will use to determine\n// whether or not to ask user to confirm prior to navigating away from\n// the route; it is NOT a built-in property of the route object and can be\n// anything we want, which makes route flow control very flexible/powerful\nconst myRoutes = createMyRoutes({\n  homeRoute: {\n    dirtyCheck: false,\n    path: '/home',\n  },\n  signupRoute: {\n    dirtyCheck: true,\n    path: '/sign-up',\n  },\n});\n\n// this is just a contrived function that emulates checking whether or\n// not the current route is dirty. For demonstration purposes, we don't\n// really check the current route for dirty state; instead, we just\n// always return true (i.e. the route is always dirty)\nfunction fakeDirtyCheck() {\n  const randomDirtyState = Math.random() < 0.5 ? true : false;\n  return randomDirtyState;\n}\n\n// here we create a new instance of the CoreRouter class and pass in\n// our routes object; we also pass in an object that implements two\n// router lifecycle callbacks\nconst myRouter = CoreRouter.initialize(myRoutes, {\n  onRouteRequest: (routeRequest) => {\n    // if the old route has a dirtyCheck property set to `true` then\n    // we check to see if it is in fact dirty\n    const isDirty = routeRequest.oldRoute.dirtyCheck ? fakeDirtyCheck() : false;\n\n    if (isDirty) {\n      // since the old route is dirty, we prompt the user to confirm the\n      // navigation and return a promise that resolves with the answer\n      const answer = window.confirm('Are you sure you want to navigate away?');\n      return Promise.resolve(answer);\n    }\n\n    // this means either the old route is NOT dirty or it does not\n    // require a dirty check, so we return true to allow the navigation\n    //\n    // we could've also omitted the return altogether and it would have\n    // the same effect, but returning true is more explicit\n    return true;\n  },\n  onRouteChange: (routeChange) => {\n    // this is where we would perform any post-processing logic, which\n    // typically means rendering the requested route. How to do this\n    // ranges based on the UI framework being used, so here we simply\n    // log the route path to the console.\n    //\n    // If you're using React or want to create an abstraction for a\n    // different rendering package/framework, you should definitely\n    // check out the Core React Router abstraction, which has the\n    // rendering logic sweetly baked in.\n    console.log(`TODO: Render the approved route: ${routeChange.route.path}`);\n  },\n});\n\nmyRouter.navigate(\n  // first, nav to the signup route, which will require a dirty check\n  // before being allowed to navigate away from it\n  myRoutes.signupRoute\n  // next, request to nav to home rout, which should trigger a confirmation\n  myRoutes.homeRoute\n);\n"})})]})}function d(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);