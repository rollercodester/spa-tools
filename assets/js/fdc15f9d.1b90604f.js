"use strict";(self.webpackChunk_spa_tools_website=self.webpackChunk_spa_tools_website||[]).push([[4431],{1658:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var s=n(7458),o=n(7996),r=n(5207);const i={title:"useIsHovered",pagination_label:"Interaction Hooks: useIsHovered",pagination_next:"interaction-hooks/use-is-overflowed",pagination_prev:"interaction-hooks/use-infinite-scroll",sidebar_label:"useIsHovered",slug:"/interaction-hooks/use-is-hovered"},a="useIsHovered()",l={id:"interaction-hooks/use-is-hovered",title:"useIsHovered",description:"As much as we strive to use pure CSS for native UI state detection, sometimes we find ourselves in situations where CSS can't quite get us there, and so we find ourselves leaning on JavaScript to interact with DOM events.",source:"@site/docs/interaction-hooks/use-is-hovered.mdx",sourceDirName:"interaction-hooks",slug:"/interaction-hooks/use-is-hovered",permalink:"/spa-tools/interaction-hooks/use-is-hovered",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"useIsHovered",pagination_label:"Interaction Hooks: useIsHovered",pagination_next:"interaction-hooks/use-is-overflowed",pagination_prev:"interaction-hooks/use-infinite-scroll",sidebar_label:"useIsHovered",slug:"/interaction-hooks/use-is-hovered"},sidebar:"docs",previous:{title:"Interaction Hooks: useInfiniteScroll",permalink:"/spa-tools/interaction-hooks/use-infinite-scroll"},next:{title:"Interaction Hooks: useIsOverflowed",permalink:"/spa-tools/interaction-hooks/use-is-overflowed"}},u={},d=[{value:"Usage",id:"usage",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Returns",id:"returns",level:3}];function c(e){const t={code:"code",h1:"h1",h3:"h3",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.D_,{packageName:"@spa-tools/interaction-hooks"}),"\n",(0,s.jsx)(t.h1,{id:"useishovered",children:"useIsHovered()"}),"\n",(0,s.jsx)(t.p,{children:"As much as we strive to use pure CSS for native UI state detection, sometimes we find ourselves in situations where CSS can't quite get us there, and so we find ourselves leaning on JavaScript to interact with DOM events."}),"\n",(0,s.jsxs)(t.p,{children:["In that vain, if you find yourself dealing with complex hover interactions, the ",(0,s.jsx)(t.code,{children:"useIsHovered"})," hook will most certainly make the task much, much eaiser."]}),"\n",(0,s.jsx)(t.h3,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"import { useRef } from 'react';\nimport { useIsHovered } from '@spa-tools/interaction-hooks';\n\nfunction UseIsHoveredExample() {\n  // here we simply setup refs to all elements we want\n  // to track hover state for\n  const buttonRef = useRef<HTMLButtonElement>(null);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const spanRef = useRef<HTMLSpanElement>(null);\n  // yes! you can also track hover state for an array of elements\n  const arrayRef = useRef<HTMLButtonElement[]>([]);\n\n  // then we use different hook instances to track the\n  // hover state for the above element refs\n  const isButtonHovered = useIsHovered(buttonRef);\n  const isInputHovered = useIsHovered(inputRef);\n  const isSpanHovered = useIsHovered(spanRef);\n  const isButtonArrayHovered = useIsHovered(arrayRef);\n\n  const getHoverStateText = () => {\n    if (isButtonHovered) {\n      return 'Very first button is hovered!';\n    }\n    if (isInputHovered) {\n      return 'Input is hovered!';\n    }\n    if (isSpanHovered) {\n      return 'Text is hovered!';\n    }\n    if (isButtonArrayHovered) {\n      return 'One of the six buttons from cluster is hovered!';\n    }\n\n    return 'Nothing is hovered!';\n  };\n\n  return (\n    <div>\n      <div>\n        <button ref={buttonRef}>Hover me!</button>\n        <input ref={inputRef} value='No, hover over me!' />\n        <div>\n          Don&apos;t listen to them, hover over{' '}\n          <span ref={spanRef} style={{ color: 'purple', cursor: 'pointer', fontWeight: 800 }}>\n            this text\n          </span>{' '}\n          instead!\n        </div>\n      </div>\n      <div>\n        <button ref={(el: HTMLButtonElement) => (arrayRef.current[0] = el)}/>Hover</button>\n        <button ref={(el: HTMLButtonElement) => (arrayRef.current[1] = el)}/>Over</button>\n        <button ref={(el: HTMLButtonElement) => (arrayRef.current[2] = el)}/>Any</button>\n        <button ref={(el: HTMLButtonElement) => (arrayRef.current[3] = el)}/>One</button>\n        <button ref={(el: HTMLButtonElement) => (arrayRef.current[4] = el)}/>Of</button>\n        <button ref={(el: HTMLButtonElement) => (arrayRef.current[5] = el)}/>Us</button>\n      </div>\n      <h2>{getHoverStateText()}</h2>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Name"}),(0,s.jsx)(t.th,{children:"Type"}),(0,s.jsx)(t.th,{children:"Required?"}),(0,s.jsx)(t.th,{children:"Default"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsx)(t.tbody,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"elem"})}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"React.RefObject"})}),(0,s.jsx)(t.td,{children:"yes"}),(0,s.jsx)(t.td,{children:"-"}),(0,s.jsx)(t.td,{children:"Holds a ref to the target element we want to watch for hover events"})]})})]}),"\n",(0,s.jsx)(t.h3,{id:"returns",children:"Returns"}),"\n",(0,s.jsxs)(t.p,{children:["Returns ",(0,s.jsx)(t.code,{children:"boolean"})," that will be ",(0,s.jsx)(t.code,{children:"true"})," when the respective target element is hovered."]})]})}function h(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);