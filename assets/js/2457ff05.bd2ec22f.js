"use strict";(self.webpackChunk_spa_tools_website=self.webpackChunk_spa_tools_website||[]).push([[4718],{7626:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>u,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>h});var r=o(7458),n=o(7996),a=o(5207);const i={title:"Pre-Route Auth Check",pagination_label:"Core Router Guide: Pre-Route Auth Check",pagination_next:"core-router/guide-confirmation",pagination_prev:"core-router/getting-started",sidebar_label:"Pre-Route Auth Check",slug:"/core-router/guides/auth-check"},u="Pre-Route Auth Check",s={id:"core-router/guide-auth-check",title:"Pre-Route Auth Check",description:"The @spa-tools/core-router package provides a way to execute pre-processing logic before navigating to a route. A common scenario that falls into this workflow is performing a check to ensure the user is authenticated prior to route execution.",source:"@site/docs/core-router/guide-auth-check.mdx",sourceDirName:"core-router",slug:"/core-router/guides/auth-check",permalink:"/spa-tools/core-router/guides/auth-check",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Pre-Route Auth Check",pagination_label:"Core Router Guide: Pre-Route Auth Check",pagination_next:"core-router/guide-confirmation",pagination_prev:"core-router/getting-started",sidebar_label:"Pre-Route Auth Check",slug:"/core-router/guides/auth-check"},sidebar:"docs",previous:{title:"Core Router: Getting Started",permalink:"/spa-tools/core-router"},next:{title:"Core Router Guide: Pre-Nav Confirmation",permalink:"/spa-tools/core-router/guides/confirmation"}},c={},h=[];function l(e){const t={code:"code",h1:"h1",p:"p",pre:"pre",...(0,n.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.D_,{packageName:"@spa-tools/core-router"}),"\n",(0,r.jsx)(t.h1,{id:"pre-route-auth-check",children:"Pre-Route Auth Check"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"@spa-tools/core-router"})," package provides a way to execute pre-processing logic before navigating to a route. A common scenario that falls into this workflow is performing a check to ensure the user is authenticated prior to route execution."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"import { CoreRouter, routesFactory } from '@spa-tools/core-router';\n\nconst createMyRoutes = routesFactory();\n\n// here we create two routes, one that requires auth and one that does not\n//\n// the authCheck is a 100% custom property that we will use to determine\n// whether or not authorization is required before allowing navigation to\n// the route; it is NOT a built-in property of the route object and can be\n// anything we want, which makes route flow control very flexible/powerful\nconst myRoutes = createMyRoutes({\n  loginRoute: {\n    authCheck: false,\n    path: '/login',\n  },\n  membersOnlyRoute: {\n    authCheck: true,\n    path: '/members-only',\n  },\n});\n\n// this is just a contrived function that emulates an auth check by\n// returning a promise that resolves to a random boolean\nfunction fakeAuthCheck() {\n  const randomAuthState = Math.random() < 0.5 ? true : false;\n  return Promise.resolve(randomAuthState);\n}\n\n// here we create a new instance of the CoreRouter class and pass in\n// our routes object; we also pass in an object that implements two\n// router lifecycle callbacks\nconst myRouter = CoreRouter.initialize(myRoutes, {\n  onRouteRequest: async (routeRequest) => {\n    // if the new route has an authCheck property set to `true`\n    // then we will perform an async check to see if the user\n    // is authorized to navigate to this route\n    const isAuthorized = routeRequest.newRoute.authCheck ? await fakeAuthCheck() : true;\n\n    if (!isAuthorized) {\n      // if the user is not authorized to navigate to the route, we\n      // will redirect to the login route; we pass the original route\n      // request as state so that the login view can hypothetically\n      // redirect back to the original route after login\n      //\n      // we could've just called the navigate method here, but to keep\n      // the browser history clean, we instead perform a redirect by\n      // returning a 2-element tuple containing redirect route and state\n      return [myRoutes.loginRoute, routeRequest];\n    }\n\n    // this means either the user is authorized or the route does not\n    // require authorization, so we return true to allow the navigation\n    //\n    // we could've also omitted the return altogether and it would have\n    // the same effect, but returning true is more explicit\n    return true;\n  },\n  onRouteChange: (routeChange) => {\n    // this is where we would perform any post-processing logic, which\n    // typically means rendering the requested route. How to do this\n    // ranges based on the UI framework being used, so here we simply\n    // log the route path to the console.\n    //\n    // If you're using React or want to create an abstraction for a\n    // different rendering package/framework, you should definitely\n    // check out the Core React Router abstraction, which has the\n    // rendering logic sweetly baked in.\n    console.log(`TODO: Render the approved route: ${routeChange.route.path}`);\n  },\n});\n\nmyRouter.navigate(\n  // request to nav to a route that requires auth\n  myRoutes.membersOnlyRoute\n);\n"})})]})}function d(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);